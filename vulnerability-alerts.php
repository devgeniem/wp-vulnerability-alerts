<?php
	
/**
 * Plugin Name: Vulnerability Alerts
 * Description: Scans your system to find vulnerabilities listed in WPScan Vulnerability Database. Geniem fork.
 * Plugin URI: https://github.com/devgeniem/wp-vulnerability-alerts
 * Version: 1.6
 * Author: Juhani Hakanen
 * License: GPL2
 * License URI: https://www.gnu.org/licenses/gpl-2.0.html
 * Text Domain: vulnerability-alerts
 */

// File Security Check
defined('ABSPATH') or die("No script kiddies please!");
	

class VulnerabiltyAlerts {
	
	// Plugin name
	static public $id = 'vulnerability-alerts';
	
	// Report shortcut
	static public $report = array();
	
	// Arguments to WP Remote Get
	static public $remote = array(
		'user-agent' => 'WordPress Plugin Vulnerability Alerts'
		);
	
	/*
	* Initialize actions
	*/
	static public function init() {

		// Languages
		load_plugin_textdomain(self::$id, false, dirname(plugin_basename(__FILE__)) . '/languages');
		
		// Arguments to wp remote get
		self::$remote['user-agent'] .=  '; ' . get_bloginfo('url');
		
		// Report
		self::$report = get_option(self::$id);
		
		// Hooks
		add_action('admin_menu', array(__CLASS__, 'menu'));
		add_action('admin_bar_menu', array(__CLASS__, 'admin_bar'), 65); // Between Updates, Comments and New Content menu
		add_action('admin_init', array('VulnerabiltyAlerts_Notification', 'init'));
		add_action(self::$id . '_schedule', array(__CLASS__, 'schedule'), 999);
		add_filter('plugin_action_links_' . plugin_basename(__FILE__), array(__CLASS__, 'add_action_links'));		
	
	}
	

	/*
	* Plugins Loaded
	*/
	static public function loaded() {

		// Languages
		load_plugin_textdomain(self::$id, false, dirname(plugin_basename(__FILE__)) . '/languages');

	}
	
	/*
	* Activate actions
	*/
	static public function activate() {
		
		wp_schedule_event(time(), 'daily', self::$id . '_schedule');
		self::verify();
		
	}
	
	/*
	* Deactivate actions
	*/
	static public function deactivate() {
		
		wp_clear_scheduled_hook(self::$id . '_schedule');
		
	}
	
	/*
	* Schedule and event to run verify() function
	*/
	static public function schedule() {
		
		self::verify();
		
		// Notify by mail when solicited
		VulnerabiltyAlerts_Notification::notify();

	}
	
	/*
	* Create a shortcut on Admin Bar to show the total of vulnerabilities found
	*/
	static public function admin_bar($wp_admin_bar) {
	
		if(!current_user_can('manage_options'))
			return;
			
		$report = self::$report;
		$total = self::get_total();
		
		if(!empty($report) and $total > 0) {
			$args = array(
				'id' => self::$id,
				'title' => '<span class="ab-icon dashicons-shield"></span><span class="ab-label">' . $total .'</span>',
				'href' => admin_url('tools.php?page=' . self::$id),
				'meta' => array(
					'title' => sprintf(_n('%d vulnerability found', '%d vulnerabilities found', $total, self::$id), $total)
				)
			);
			$wp_admin_bar->add_node($args);
		}
		
	}
	
	/*
	* Return the total of vulnerabilities found
	*/
	static public function get_total() {
		$report = self::$report;
		$options = get_option(self::$id . '_notification');
		$ignored = empty($options['ignored']) ? array() : $options['ignored'];
		
		$total = 0;
		$total += $report['wordpress']['total'];
		$total += $report['plugins']['total'];
		$total += $report['themes']['total'];
				
		// WordPress ignored
		if($report['wordpress']['total'] > 0) {
			foreach($report['wordpress']['vulnerabilities'] as $item) {
				if(in_array($item->id, $ignored))
					$total -= 1;
			}
		}
		
		// Plugins ignored
		if($report['plugins']['total'] > 0) {
			foreach($report['plugins'] as $plugin) {
				if(empty($plugin['vulnerabilities'])) 
					continue;
				foreach($plugin['vulnerabilities'] as $item) {
					if(in_array($item->id, $ignored))
						$total -= 1;
				}
			}
		}
		
		// Themes ignored
		if($report['themes']['total'] > 0) {
			foreach($report['themes'] as $theme) {
				if(empty($theme['vulnerabilities'])) 
					continue;
				foreach($theme['vulnerabilities'] as $item) {
					if(in_array($item->id, $ignored))
						$total -= 1;
				}
			}
		}
		
		return $total;
	}
	
	/*
	* Create a menu on Tools section
	*/
	static public function menu() {
		
		add_management_page(__('Vulnerability Alerts', self::$id), __('Vulnerability Alerts', self::$id), 'manage_options', self::$id, array(__CLASS__, 'report'));
	
	}
	
	/*
	* Include a shortcut on Plugins Page
	*
	* @param array $links - Array of links provided by the filter
	* @return array
	*/
	static public function add_action_links($links) {
		
		$links[] = '<a href="' . admin_url('tools.php?page=' . self::$id) . '">' . __('View') . '</a>';
		return $links;
		
	}

	/*
	* Function to verify on WpScan Database for vulnerabilities
	*/
	static public function verify() {
				
		// Suppports during WP Cron
		if(!function_exists('get_plugins'))
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		
		$report = array();
		
		// WordPress
		$report['wordpress'] = array();
		$report['wordpress']['total'] = 0;
		$version = get_bloginfo('version');
		$response = wp_remote_get('https://wpvulndb.com/api/v2/wordpresses/' . str_replace('.', '', $version), self::$remote);
		if(is_array($response)) {
			$result = (array) json_decode($response['body']);
			if(!empty($result)) {
				$report['wordpress']['vulnerabilities'] = self::get_vulnerabilities($result, $version);
				$report['wordpress']['total'] = count($report['wordpress']['vulnerabilities']);
			}
		}

		// Plugins
		$report['plugins'] = array();
		$report['plugins']['total'] = 0;
		foreach(get_plugins() as $name => $details) {
			$parts = pathinfo($name);
			$response = wp_remote_get('https://wpvulndb.com/api/v2/plugins/' . $parts['dirname'], self::$remote);
			if(is_array($response)) {
				$result = (array) json_decode($response['body']);
				if(!empty($result)) {
					$report['plugins'][$name]['vulnerabilities'] = self::get_vulnerabilities($result, $details['Version']);
					$report['plugins']['total'] += count($report['plugins'][$name]['vulnerabilities']);
				}
			}
		}
		
		// Themes
		$report['themes'] = array();
		$report['themes']['total'] = 0;
		foreach(wp_get_themes() as $name => $details) {
			$response = wp_remote_get('https://wpvulndb.com/api/v2/themes/' . $name, self::$remote);
			if(is_array($response)) {
				$result = (array) json_decode($response['body']);
				if(!empty($result)) {
					$report['themes'][$name]['vulnerabilities'] = self::get_vulnerabilities($result, $details['Version']);
					$report['themes']['total'] += count($report['themes'][$name]['vulnerabilities']);
				}
			}
		}
			
		// Caching
		$report['cache'] = strtotime(current_time('mysql'));
		update_option(self::$id, $report, true);
		self::$report = $report;

        self::slack_report_geniem();
        self::check_cron_geniem();
	}

	static public function check_cron_geniem() {
        global $wpdb;
        $result = $wpdb->get_results("SELECT * FROM ".$wpdb->options." WHERE option_name = 'cron'");
        $vulnerability_alerts_schedule_count = substr_count($result[0]->option_value, 'vulnerability-alerts_schedule');

        // If there's too many duplicate cron events or none at all; create single cron event.
        if ($vulnerability_alerts_schedule_count !== 1) {
            wp_clear_scheduled_hook(self::$id . '_schedule');
            wp_schedule_event(time(), 'daily', self::$id . '_schedule');
        }
    }

	static public function slack_report_geniem() {
	    $report = self::$report;
	    $slack_vulnerabilities = array();

        if (!empty($report['wordpress']['vulnerabilities'])) {
            foreach ($report['wordpress']['vulnerabilities'] as $vulnerability) {
                $slack_vulnerabilities[] = $vulnerability->title;
            }
        }

        foreach ($report['plugins'] as $plugin) {
            if (is_array($plugin)) {
                if (!empty($plugin['vulnerabilities'])) {
                    foreach ($plugin['vulnerabilities'] as $vulnerability) {
                        $slack_vulnerabilities[] = $vulnerability->title;
                    }
                }
            }
        }

        if (empty($slack_vulnerabilities)) {
        	return false;
        }

        if (function_exists('curl_version')) {
            if (defined('PLUGIN_SECURITY_SCANNER_SLACK_KEY')) {
                $slack_message_implode = implode("\n\n", $slack_vulnerabilities);
                $slack_message = get_site_url()."\n".$slack_message_implode;
                $curl_message = array('payload' => json_encode(array('text' => $slack_message)));
                $c = curl_init(PLUGIN_SECURITY_SCANNER_SLACK_KEY);
                curl_setopt($c, CURLOPT_SSL_VERIFYPEER, false);
                curl_setopt($c, CURLOPT_POST, true);
                curl_setopt($c, CURLOPT_POSTFIELDS, $curl_message);
                curl_exec($c);
                curl_close($c);
            }
        }
        else {
            $debug_to = 'support@geniem.com';
            $debug_subject = 'Automaattinen tietoturvatarkistus ei toimi - cURL puuttuu.';
            $debug_body = get_site_url()."<br><br>Palvelimelta ei löydy cURLia, joten automaattinen tietoturvatarkistus epäonnistuu.<br><br>Tämä sähköposti on lähetetty vulnerability-alerts.php:sta.";
            $debug_headers = array('Content-Type: text/html; charset=UTF-8');

            wp_mail($debug_to, $debug_subject, $debug_body, $debug_headers);
        }
    }

	/*
	* Report Page
	*/
	static public function report() {
		
		// Button Check Now
		if(isset($_POST['verify'])) {
			add_settings_error(self::$id, 'update', __('Report updated.', self::$id), 'updated');
			self::verify();
		}
				
		$report = self::$report;
		include 'report.php';
		
	}
	
	/*
	* Filter vulnerability list from WPScan
	*
	* @param array $data - Report data for the element to check
	* @param string $version - Installed version
	* @return string
	*/
	static public function get_vulnerabilities($data, $version) {
		
		$list = array();
		$key = key($data);
		
		foreach($data[$key]->vulnerabilities as $item) {
			if($item->fixed_in) {
            	if(version_compare($version, $item->fixed_in, '<'))
	                $list[] = $item;
			} else {
            	$list[] = $item;
        	}
		}
		
		return $list;
		
	}
	
	/*
	* List vulnerabilities on screen
	*
	* @param string $type - Type of report: wordpress, plugins, themes
	* @param string $name - key name of the element
	* @return string
	*/
	static public function list_vulnerabilities($type, $name = null) {

		$report = self::$report[$type];
		if(array_key_exists($name, $report))
			$report = $report[$name];

		if(!isset($report['vulnerabilities'])) {
			_e('Report not available', self::$id);
			return;
		}
	
		$list = array();
		
		foreach($report['vulnerabilities'] as $item) {
			$html  = '<a href="' . esc_url('https://wpvulndb.com/vulnerabilities/' . $item->id) . '" target="_blank">';
			$html .= self::get_vulnerability_title($item);
			$html .= '</a>';
			$list[] = $html;
		}
		
		echo empty($list) ? '- -' : join('<br>', $list);
		
	}
	
	/*
	* Get vulnerability title
	*
	* @param string $vulnerability - element array
	* @return string
	*/
	static public function get_vulnerability_title($vulnerability) {
		$title = esc_html($vulnerability->title) . ' - ';
		$title .= empty($vulnerability->fixed_in) ? __('Not fixed', self::$id) : sprintf(__('Fixed in version %s', self::$id),  $vulnerability->fixed_in);
		return $title;
	}
		
	/*
	* Show status icons: checked, attention and error
	*
	* @param string $type - Type of report: wordpress, plugins, themes
	* @param string $name - key name of the element
	* @return string
	*/
	static public function get_status($type, $name = null) {
		
		$report = self::$report[$type];
		if(array_key_exists($name, $report))
			$report = $report[$name];

		if(!isset($report['vulnerabilities']))
			return '&nbsp; <span class="dashicons dashicons-no-alt" style="color:gray"></span>';

		if(empty($report['vulnerabilities']))
			return '&nbsp; <span class="dashicons dashicons-yes" style="color:green"></span>';
		else
			return '&nbsp; <span class="dashicons dashicons-warning" style="color:Crimson"></span>';

	}
	
}

/*
* Notification System
*/
class VulnerabiltyAlerts_Notification extends VulnerabiltyAlerts {
	
	/*
	* Notification Options
	*/
	static public function init() {
		
		$report = self::$report;
				
		$total = 0;
		$total += $report['wordpress']['total'];
		$total += $report['plugins']['total'];
		$total += $report['themes']['total'];
						
		register_setting(self::$id . '_notification', self::$id . '_notification', array(__CLASS__, 'validate'));
		
		add_settings_section(
		    self::$id . '_notification_section',
		    __('Notification', self::$id),
		    array(__CLASS__, 'introduction'),
		    self::$id . '_notification');

		add_settings_field(
		    'email',
		    __('E-mail Address', self::$id),
		    array(__CLASS__, 'field_email'), 
		    self::$id . '_notification',
		    self::$id . '_notification_section');
		    
		add_settings_field(
		    'interval',
		    __('Send E-mail Alerts', self::$id),
		    array(__CLASS__, 'field_interval'), 
		    self::$id . '_notification',
		    self::$id . '_notification_section');

		if($total > 0) {
			add_settings_field(
			    'ignored',
			    __('Vulnerabilities to Ignore', self::$id),
			    array(__CLASS__, 'field_ignored'), 
			    self::$id . '_notification',
			    self::$id . '_notification_section');
		}
				     		
	}
	
	/*
	* Introduction
	*/
	static public function introduction() {

		echo '<p>' . __('Fill the options below if you want to be notified by mail about new vulnerabilities.', self::$id) . '</p>';

	}
	
	/*
	* Field E-mail
	*/
	static public function field_email() {

		$options = get_option(self::$id . '_notification');
		echo '<input type="text" name="' . self::$id . '_notification[email]" value="' . $options['email'] . '" class="regular-text">';

	}
	
	/*
	* Field Interval
	*/
	static public function field_interval() {

		$options = get_option(self::$id . '_notification');
		$interval = empty($options['interval']) ? 'd' : $options['interval'];
		echo '<select name="' . self::$id . '_notification[interval]">';
		echo '<option value="d" ' . selected('d', $interval, false) . '>' . __('Daily', self::$id) . '</option>';
		echo '<option value="1" ' . selected(1, $interval, false) . '>' . __('Every Monday', self::$id) . '</option>';
		echo '<option value="2" ' . selected(2, $interval, false) . '>' . __('Every Tuesday', self::$id) . '</option>';
		echo '<option value="3" ' . selected(3, $interval, false) . '>' . __('Every Wednesday', self::$id) . '</option>';
		echo '<option value="4" ' . selected(4, $interval, false) . '>' . __('Every Thursday', self::$id) . '</option>';
		echo '<option value="5" ' . selected(5, $interval, false) . '>' . __('Every Friday', self::$id) . '</option>';
		echo '<option value="6" ' . selected(6, $interval, false) . '>' . __('Every Saturday', self::$id) . '</option>';
		echo '<option value="7" ' . selected(7, $interval, false) . '>' . __('Every Sunday', self::$id) . '</option>';
		echo '</selected>';

	}
	
	/*
	* Field Ignore
	*/
	static public function field_ignored() {

		$options = get_option(self::$id . '_notification');
		$ignored = empty($options['ignored']) ? array() : $options['ignored'];

		self::list_vulnerabilities_to_ignore('wordpress');
			
		foreach(get_plugins() as $name => $details)
			self::list_vulnerabilities_to_ignore('plugins', $name);
		
		foreach(wp_get_themes() as $name => $details)
			self::list_vulnerabilities_to_ignore('themes', $name);
			
	}
	
	/*
	* List of vulnerabilities
	*
	* @param string $type - Type of report: wordpress, plugins, themes
	* @param string $name - key name of the element
	* @return string
	*/
	static public function list_vulnerabilities_to_ignore($type, $name = null) {

		$report = self::$report[$type];
		if(array_key_exists($name, $report))
			$report = $report[$name];

		if(!isset($report['vulnerabilities'])) {
			return null;
		}
	
		$options = get_option(self::$id . '_notification');
		$ignored = empty($options['ignored']) ? array() : $options['ignored'];
		
		foreach($report['vulnerabilities'] as $item) {
			echo '<label><input type="checkbox" name="' . self::$id . '_notification[ignored][]" value="' . $item->id . '" ' . (in_array($item->id, $ignored) ? 'checked="checked"' : null) . '> ';
			echo self::get_vulnerability_title($item);
			echo '</label><br>';
		}

	}
	
	/*
	* Validating fields
	*/
	static public function validate($input) {
		
		// Email
		if(!empty($input['email']) && !is_email($input['email']))
		    add_settings_error(self::$id . '_notification', 'invalid-email', __('You have entered an invalid e-mail address.', self::$id));

		return $input;
		
	}
	
	/*
	* Sending notification
	*/
	static public function notify() {
		
		// Suppports during WP Cron
		if(!function_exists('get_plugins'))
			require_once ABSPATH . 'wp-admin/includes/plugin.php';

		$report = self::$report;
		$total = self::get_total();

		if($total == 0)
			return;
		
		$options = get_option(self::$id . '_notification');
		$email = empty($options['email']) ? null : $options['email'];
		$interval = empty($options['interval']) ? 'd' : $options['interval'];
		$ignored = empty($options['ignored']) ? array() : $options['ignored'];

		// Check email				
		if(empty($email))
			return;

		// Check weekly interval
		if(is_numeric($interval) && date('N') != $interval)
			return;
		
		// Send email
		$has_vulnerabilities = false;
		$msg  = '<doctype html><html><head><meta charset="utf-8"></head><body>';
		$msg .= '<p>' . __('Hello Friend,', self::$id) . '</p>';
		$msg .= '<p>' . sprintf(__('Some vulnerabilities were found in %s, visit the site for more details.', self::$id), '<a href="' . get_bloginfo('url') . '">' . get_bloginfo('name') . '</a>') . '</p>';
		
		// WordPress
		if($report['wordpress']['total'] > 0) {
			$list = self::email_vulnerabilities('wordpress');
			if(!empty($list)) {
				$has_vulnerabilities = true;
				$msg .= '<p><b>WordPress</b><br>';
				$msg .= join('<br>', $list) . '</p>';
			}
		}
		
		// Plugins
		if($report['plugins']['total'] > 0) {
			foreach(get_plugins() as $name => $details) {
				$list = self::email_vulnerabilities('plugins', $name);
				if(!empty($list)) {
					$has_vulnerabilities = true;
					$msg .= '<p><b>' . __('Plugins', self::$id) . ' ' . $details['Name']  . '</b><br>';
					$msg .= join('<br>', $list) . '</p>';
				}
			}
		}
		
		// Themes
		if($report['themes']['total'] > 0) {
			foreach(wp_get_themes() as $name => $details) {
				$list = self::email_vulnerabilities('themes', $name);
				if(!empty($list)) {
					$has_vulnerabilities = true;
					$msg .= '<p><b>' . __('Themes', self::$id) . ' ' . $details['Name']  . '</b><br>';
					$msg .= join('<br>', $list) . '</p>';
				}
			}
		}
		
		$msg .= '<p>' . __('Hope this help!', self::$id) . '</p>';
		$msg .= '</body></html>';
				
		if($has_vulnerabilities) {	
			$subject = sprintf(__('Some vulnerabilities were found in %s', self::$id), get_bloginfo('name'));
			$headers = array('Content-Type: text/html; charset=UTF-8');
			wp_mail($options['email'], $subject, $msg, $headers);
		}
		
	}
	
	/*
	* List of vulnerabilities to send by mail
	*/
	static public function email_vulnerabilities($type, $name = null) {

		$report = self::$report[$type];
		if(array_key_exists($name, $report))
			$report = $report[$name];

		if(!isset($report['vulnerabilities'])) {
			return null;
		}
		
		$options = get_option(self::$id . '_notification');
		$ignored = empty($options['ignored']) ? array() : $options['ignored'];

		$list = array();
		
		foreach($report['vulnerabilities'] as $item) {
			if(!in_array($item->id, $ignored)) {
				$html  = '<a href="' . esc_url('https://wpvulndb.com/vulnerabilities/' . $item->id) . '" target="_blank">';
				$html .= self::get_vulnerability_title($item);
				$html .= '</a>';
				$list[] = $html;
			}
		}
		
		return $list;
		
	}
	
}


// Activating
register_activation_hook(__FILE__, array('VulnerabiltyAlerts', 'activate'));

// Deactivating
register_deactivation_hook(__FILE__, array('VulnerabiltyAlerts', 'deactivate'));

// Initialize
add_action('init', array('VulnerabiltyAlerts', 'init'));

?>